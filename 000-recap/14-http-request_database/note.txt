Data Fetching & HTTP requests
:sending & receiving Data via HTTP

- how to connect a backend/ database
- fetching data
- sending data 

// How (not) to connect to a database

- with React, you build a client-side web application (= it runs in the browser)

- You communicate with a backend(API) via HTTP requests 

- You should not try to connect to a database directly (-> credentials would be exeposed)

- Frontend (React app) & backend (API) are often separated (=separate projects)

- You can build a fullstack React app (= blend frontend & backend) via NextJS or Remix


// How NOT to send HTTP Requests 

what is fetch and promise?
Fetch then returns a promise which is a JavaScript value that will eventually resolve to another value.
So it's basically a wrapper object around a value that's not there yet but that will eventually be there.
In this case, it's a wrapper around an eventually received response object.

But this function, which you're passing to then will be executed by the browser only once the response is there. 
So not instantly, but at some point in the future.

useEffect(() => {
    // update UI with get request
    fetch("http://localhost:3000/places")
      .then(response => {
        return response.json(); //returns another promise
      })
      .then(resData => {
        console.log(resData);
        setAvailablePlaces(resData.places);
      });
}, []);


// Using async & await

async/await generally has a few advantages over .then() in terms of readability, maintainability, and error handling. 

useEffect(() => {
    // update UI with get request
    async function fetchPlaces() {
      const response = await fetch("http://localhost:3000/places");
      const resData = await response.json();
      setAvailablePlaces(resData.places);
    }

    fetchPlaces();
  }, []);


// Loading state

(AvailablePlaces)
const [isFetching, setIsFetching] = useState(false);

useEffect(() => {
    // update UI with get request
    async function fetchPlaces() {
      setIsFetching(true); // loading state
      const response = await fetch("http://localhost:3000/places");
      const resData = await response.json();
      setAvailablePlaces(resData.places);
      setIsFetching(false); // loading state
    }

    fetchPlaces();
  }, []);

return (
    <Places
      title="Available Places"
      places={availablePlaces}
      isLoading={isFetching}
      loadingText="Fetching place data..."
      fallbackText="No places available."
      onSelectPlace={onSelectPlace}
    />
  );

(Places)

{isLoading && <p className="fallback-text">{loadingText}</p>}
{!isLoading && places.length === 0 && (
        <p className="fallback-text">{fallbackText}</p>
      )}
{!isLoading && places.length > 0 && (
        ...contents....
      )}