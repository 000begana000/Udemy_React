Working with forms & user input

- what's difficult about forms?
- handling form submission & validating user input
- using built-in form features
- building custom solutions

// What are forms & what's tricky about them?
<form submission>
- handling submission is relatively easy
- entered values can be managed via state
- alternatively, they can be extracted via refs
- or via formdata and native browser features

<input validation>
- providing a good user experience is tricky
- you can validate on every keystroke -> errors may be shown too early 
- you can validate on lost focus -> errors may be shown too long


// Handling form submission

** htmlFor = for in html and it works with id in input 
<label htmlFor="email">Email</label>

** page refreshing is happening because form tag sending http request default
=> how to prevent default ?

1. type="button" (default type is submit)
<button type="button" className="button" onClick={handleSubmit}>
    Login
</button>

2. instead of onClick, use onSubmit on <form>
<form onSubmit={handleSubmit}>

function handleSubmit(event) {
    event.preventDefault(); <======
    console.log("submitted!");
}


// Managing & getting user input via state & genetic handlers 

const [enteredValues, setEnteredValues] = useState({
    email: "",
    password: "",
  });

- onchange occurs when the element loses focus, after the content has been changed
  function handleInputChange(identifier, value) {
    setEnteredValues(prevState => ({
      ...prevState,
      [identifier]: value, //already extracted from onChange event
    }));
  }

<input
    id="email"
    type="email"
    name="email"
    onChange={event => handleInputChange("email", event.target.value)}
    value={enteredValues.email}
/>


// Getting user input via Refs 

  const email = useRef();
  const password = useRef();

  function handleSubmit(event) {
    event.preventDefault();
    const enteredEmail = email.current.value;
    const enteredPassword = password.current.value;
    console.log(enteredEmail, enteredPassword);
  }

   <input id="email" type="email" name="email" ref={email} />


// Getting values via FormData & navtive browser APIs

function handleSubmit(event) {
    event.preventDefault();

    - this feature is from brwoser, not react or custom, and it takes values from the form.
    - to do that, the input elements must have a "name" attribute

    const formData = new FormData(event.target);

    - to get multiple values from the same input name, we can use getAll => first, get all the acquisition channels

    const acquisitionChennal = formData.getAll("acquisition");

    // const eneterdEmail = formData.get('email')  <= single value
    - this gives us all the input values in key and value pairs

    const data = Object.fromEntries(formData.entries());

    - merge the acquisition channels with the data object

    data.acquisition = acquisitionChennal;
    console.log(data);
  }

// Resetting forms 

- built-in button attributes 
  <button type="reset" className="button button-flat">

type="reset"  => reset the form 
type="submit" => default, for submission
type="button" => doesn't do anything when we click 

- state login : reset the value to the empty strings
setEnteredValues({
    email: "",
    password: "",
});

- ref login : using reset event (we can use it for FormData too)
event.target.reset();


// Validating input on every keystroke via state 
- we can do this only with state login 

const emailIsInvalid =
    enteredValues.email !== "" && !enteredValues.email.includes("@");

<div className="control-error">
    {emailIsInvalid && <p>Please enter a valid email address.</p>}
</div>

Problems : 
1. when we clean up input field after write something, the error message is gone 
2. the error message shows up too fast and user can't have the chance to write valid email


// Validating input upon lost focus (blur)

- onBlur is called when we lost focus with input field.

 <input
    id="email"
    type="email"
    name="email"
    onBlur={() => handleInputBlur("email")}   <===========
    onChange={event => handleInputChange("email", event.target.value)}
    value={enteredValues.email}
/>

- create new state for onBlur state

const [didEdit, setDidEdit] = useState({
    email: false,
    password: false,
  });

- validate after the user has edited the field
  
  const emailIsInvalid = didEdit.email && !enteredValues.email.includes("@");

- onchange is called by every keystroke

  function handleInputChange(identifier, value) {
    setEnteredValues(prevState => ({
      ...prevState,
      [identifier]: value, //already extracted from onChange event
    }));

    *** reset the validation when the user starts to type again
    
    setDidEdit(prevEdit => ({
      ...prevEdit,
      [identifier]: false,
    }));
  }