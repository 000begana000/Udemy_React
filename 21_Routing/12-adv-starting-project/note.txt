loader()

    1. an extra property in router and it wants a function as a value
    2. and that function will be executed by react router when we are about to visit that route(path).
    3. it execute loader() first then component.
    4. {
            index: true,
            element: <EventsPage />, <=====
            loader: async () => {
              const response = await fetch("http://localhost:8080/events");

              if (!response.ok) {
                // we will deal with incorrect response later
              } else {
                const resData = await response.json();
                return resData.events;   <<======
              }
            },
          },
    5. react router will get the any returned values and be able to use this data at the component (in this case, EventPage)




How to use data from loader

    1. import { useLoaderData } from "react-router-dom";
    2. react dom will get promise data for us so we don't need to worry about whether loader was async function or not.
    3. const data = useLoaderData();
    4. return <EventsList events={data} />;
    5. we can use useLoaderData to the children routes directly
    6. we cannot use it higher routes 




Where should be loader() code to be stored? ====> in the component where you wanna get the response (fetch)

    1. function name is up to me but write the fetching code in Events element 
        export async function loader() {
            const response = await fetch("http://localhost:8080/events");

            if (!response.ok) {
                // we will deal with incorrect response later
            } else {
                const resData = await response.json();
                return resData.events;
            }
        }
    2. import EventsPage, { loader as eventsLoader } from "./components/Events";  ===> App
    3. {
            index: true,
            element: <EventsPage />,
            loader: eventsLoader,  <<======
          },




When does loader execute?

    1. react route will wait for the 1) data fetching first by default and render the 2) component 
    2. we don't need to worry about if there is data or not because it will be rendered when there is data only
    3. we don't need to render a loading state on the Events page




Current route transition state to User :
  wheather it is initiated, waiting for data, or if we are done.

    1. RootLayout
    2. import { useNavigation } from "react-router-dom";
    3. const navigation = useNavigation();
    4. navigation.state ===> has 3 properties in string. idle, loading, submitting
    5. {navigation.state === "loading" && <p>Loading...</p>}
    6. we can see the message already when the transition has started already.




Returning response in loader()

    1. we can return any kind of data in loader, for example number, text whatevver we want.
    2. we can also reatun new Response() function that built-in from the browser, which is a modern browser feature.
    3. we can build our own new Response() function.
    4. but the loader() is not executed on a server, but all happening in the browser. (it's still a client-side code.)
    5. return new Response('any data', {status: 201});     we can return any data and set the status 
    6. 'any data' will become the data we return through useLoaderData hook
            ====> But why do we need to use it?
    7. we can return response directly without checking if it's ok or not 
    8 // const resData = await response.json();
      // return resData.events;
      // const res = new Response("any data", { status: 201 });
      return response;        <=== without all the code above we can simply return response like this 




Which kind of code goes into loader() ?

    1. Remember, loader() is not server side code but it's executed in the browser.
    2. means we can use any broswer API in the loader() function.
    3. we can access to the localStorage, cookies and any JS codes.
    4. we cannot use hooks (like useState) because hooks work only in react components




Error handling with custom Errors 
    
    1. if (!response.ok) {
          return { isError: true, message: "Could not fetch events." }; 
       } 
    2. if (data.isError) {
          return <p>{data.message}</p>;
      }
    
    <alternative>
    3. if (!response.ok) {
        throw { message: "Could not fetch events." };
      }
    4. when an error thrown in a loader, react router renders the closet errorElement in router definition.
    5. that errorElement will be rendered as a fall-back for 404 error 
    6. but it also rendered when there is error with any route related code, including loader().
    7. element: <RootLayout />,
       errorElement: <ErrorPage />,
    8. ErrorPage will be displayed by any kind of error from any routes.
    9. remember, the "closest" errorElement will be rendered!




Extracting error data & throwing Response

    1. import { useRouteError } from "react-router-dom";  ====> we can use this hook in the errorElement
    2. if (!response.ok) {
          throw new Response(JSON.stringify({ message: "Could not fetch events." }), {
            status: 500,
          });
        }
    3. we need to use JSON.stringify to include data in new Response.
    4. const error = useRouteError(); ====> will depend on thrown Response or any kind of data.
    5. for example error.status will be 500
        500 : he server encountered an unexpected condition that prevented it from fulfilling the request
    6. we want to use new Response because it allows us to add extra status property 
    7. if (error.status === 500) {
          message = JSON.parse(error.data).message;  
                  ====> error.data allows us to reach the data that thrown from Response()
        }
    8. if (error.status === 404) {     ====> default error status from react router
          title = "Not Found!";
          message = "Could not found resourse or page.";
        }

    Summary : we throw new Response to handle any kind of errors 