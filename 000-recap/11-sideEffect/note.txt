Dealing with side effects
- understanding Side Effects & useEffect()
- Effects & Dependencies
- When Not to use useEffect()

// What is Side Effects?
- Side effects are "tasks" that don't impact the current component render cycle

  // navigator => provided by browser
  navigator.geolocation.getCurrentPosition(position => {
    // run a callback function once when we get the current location
    const sortedPlaces = sortPlacesByDistance(
      AVAILABLE_PLACES,
      position.coords.latitude,
      position.coords.longitude
    );
  });

  "we need this code to figure out the location but it's not directly related to the task, to the main goal, of this component function. because main goal of each component function is to return renderable JSX code."


// A potential problem with the Side Effect : infinite loop

  1. this operation of getting the user's location will take some time. So the first app component render cycle will be finished at the point of time where we have this location.

  navigator.geolocation.getCurrentPosition(position => {
    const sortedPlaces = sortPlacesByDistance(
      AVAILABLE_PLACES,
      position.coords.latitude,
      position.coords.longitude
    );

    2. we start with an empty array and we set this state to these sorted places once we have them.

    3. So once this operation of fetching the user's location finished and since this then triggers a new render cycle, the state will be updated with those sorted places - but it would cause an infinite loop.

    setAvailablePlaces(sortedPlaces);
  });

  
  // Using useEffect hook

  import { useEffect } from "react";

  1.  useEffect, unlike useState or useRef does not return a value.

  2.  first argument is a function that should wrap your side effect code.
  second argument is an array of dependencies of that effect function.

  3.  You will not run into this infinite loop problem. Because the idea behind useEffect is that this function which you pass as a first argument to useEffect will be executed by React "after" every component execution.

  4.  this code here will not be executed right away. Instead, it's only after the app component function execution finished. So, "after" this JSX code here has been returned.

  5.  it will only execute this effect function again if the dependency values changed.

  6.  if there is no dependencies, it only executes it once after this app component function was executed for the first time.

  useEffect(() => {
    navigator.geolocation.getCurrentPosition(position => {
      const sortedPlaces = sortPlacesByDistance(
        AVAILABLE_PLACES,
        position.coords.latitude,
        position.coords.longitude
      );

      setAvailablePlaces(sortedPlaces);
    });
  }, []);


7. fallbackText will be shown during the time where we don't have any places yet.
<Places
    title="Available Places"
    places={availablePlaces}
    fallbackText="Sorting places by distance..."
    onSelectPlace={handleSelectPlace}
/>


// Not all side Effects need useEffect

1.  use useEffect to prevent infinite loop or if you have code that can only run after the component function executed at least once.

2.  the code under is technically side effect because it doesn't update UI directly but it doesn't need to be stored in useEffect hook because we need this code to be executed when we call the handleSelectPlace function

3. this code is not causing infinite loop as well

function handleSelectPlace(id) {
    setPickedPlaces(prevPickedPlaces => {
      if (prevPickedPlaces.some(place => place.id === id)) {
        return prevPickedPlaces;
      }
      const place = AVAILABLE_PLACES.find(place => place.id === id);
      return [place, ...prevPickedPlaces];
    });

    // we don't lose these places when we reload the app. localStorage is coming from the browser
    // JSON.parse => convert is back to array
    const storedIds = JSON.parse(localStorage.getItem("selectedPlaces")) || [];

    // if there is no new id (index -1 means falshy) then store the new id
    if (storedIds.indexOf(id) === -1) {
      // localStorage.setItem(identifier, data_in_string_format);
      // JSON.stringify([id, ...storedIds]) => new id we get & storedIds
      localStorage.setItem(
        "selectedPlaces",
        JSON.stringify([id, ...storedIds])
      );
    }
  }